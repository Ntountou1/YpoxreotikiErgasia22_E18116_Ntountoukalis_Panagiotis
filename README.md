# README File

Στο συγκεκριμένο repository παρουσιάζεται η εργασία εξαμήνου μου στο μάθημα των Πληροφοριακών Συστημάτων στην οποία υλοποίησα μια Flask εφαρμογή χρησιμοποιόντας την Pymongo και την Docker MongoDB.

Στον φάκελο Test βρίσκονται όλα τα αρχεία της εργασίας. Στο πρώτο επίπεδο βρίσκεται το docker-compose.yml το οποίο συνδέει την MongoDB με το Flask. Αν χρησιμοποιήσουμε την εντολή docker-compose up -d στον editor έχουμε το εξής αποτέλεσμα:
docker-compose up -d
mongodb is up-to-date
flask is up-to-date

Οπότε είμαστε έτοιμοι να χρησιμοποιήσουμε την εφαρμογή.

Στον φάκελο flask βρίσκεται το Dockerfile που μέσω αυτού γίνεται download για να μπορεί να τρέξει το πρόγραμμα με βάση τις εκδόσεις που έχω χρησιμοποιήσει εγώ στον υπολογιστή μου. Επιπλέον βρίσκεται ένας φάκελος data που περιέχει τα jsons από τα 2 collections που χρησιμοποιήθηκαν με την MongoDB(Students,Notes) καθώς και τα αρχεία prepare_data _init_.py. Το βασικό αρχείο είναι το first_test.py στο οποίο έχει γραφτεί όλος ο κώδικας τον οποίο αναλύω συνοπτικά παρακάτω:

Αρχικά γίνεται η σύνδεση με την mongodb ώς εξής: 

client = MongoClient('mongodb://localhost:27017/')

Έπειτα επιλέγονται η βάση δεδομένων και τα collections που θα χρησιμοποιηθούν:

db = client['DigitalNotes']

students = db['Students'] -> collection με τους χρήστες
notes = db['Notes'] -> collection με τις σημειώσεις

Ακολουθεί η εισαγωγή του Flask:

app = Flask(__name__)
app.secret_key = "super secret key" -> Χρησιμοποιείται για την αποθήκευση του session, το οποίο αναλύεται στη συνέχεια.

Ακολουθούνε τα endpoints της εφαρμογής και τέλος γίνεται το run του Flask:

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000) ->Τρέχει στην πόρτα 5000
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------    
    
 Τα endpoints του Πληροφοριακού Συστήματος είναι τα εξής:


@app.route('/register_user', methods=['POST'])
  Αρχικά ο χρήστης χρειάζεται να κάνει ένα sign up στην βάση δεδομένων για να μπορεί να έχει πρόσβαση στα υπόλοιπα endpoints. Για να είναι επιτυχής η εγγραφή του, θα     πρέπει να στείλει ένα json με όλα τα κατάλληλα στοιχεία του(email, username, fullname, password). Στο backend γίνεται ένας έλεγχος αν το email χρησιμοποιείται ήδη     και ο χρήστης ενημερώνεται με κατάλληλο μήνυμα. Αν τα στοιχεία είναι ελλιπή ενημερώνεται πάλι κατάλληλα. Αν είναι όλα σωστά τότε γίνεται επιτυχώς η εγγραφή του στο     σύστημα.

1)Επιτυχής Εγγραφή
![Screenshot_1](https://user-images.githubusercontent.com/103457872/177391503-93250008-9f93-44d6-9e05-485202106991.png)

2)Email που χρησιμοποιείται ήδη
![Screenshot_2](https://user-images.githubusercontent.com/103457872/177391507-639a70df-7095-4823-8313-35ac905f112d.png)

3)Όχι ολοκληρωμένο json(λείπει το username)
![Screenshot_3](https://user-images.githubusercontent.com/103457872/177391508-460804ab-1f06-45b7-86ad-c0784f181177.png)




-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/sign_in_user', methods=['GET'])
Για την επιτυχή σύνδεση του χρήστη θα πρέπει να στείλει με arguments το email και το password του προφίλ του και αν αυτά αντιστοιχούν επιτυχώς στο προφίλ του τότε γίνεται επιτυχώς η σύνδεση, αλλιώς ενημερώνεται αντίστοιχα. Αν η σύνδεση γίνει με επιτυχία, τότε αποθηκεύτεται ένα session με το email του χρήστη το οποίο έχει ισχύ μέχρι να κλείσει τη σελίδα. Με αυτόν τον τρόπο γίνεται ο έλεγχος της σύνδεσης του στα υπόλοιπα endpoints.

1)Επιτυχής σύνδεση
![Screenshot_4](https://user-images.githubusercontent.com/103457872/177391510-e35ec6c8-b682-41f7-9e68-906fb6504dff.png)

2)Λάθος email
![Screenshot_5](https://user-images.githubusercontent.com/103457872/177391511-0601a31d-e5a6-440b-95b9-15088cb2d594.png)


3)Λάθος password
![Screenshot_6](https://user-images.githubusercontent.com/103457872/177391512-256589f0-0aba-47f3-aec9-b68924e8fdde.png)




Με την επιτυχή έκβαση του sign_in και με την αποθήκευση του session, σε όλα τα υπόλοιπα endpoints γίνεται αρχικά ο έλεγχος:
if 'email' in session:
Που με αυτό τον τρόπο ελέγχεται αν το session περίεχει το email του χρήστη. Αν δεν έχει γίνει κάποιο sign in, το session είναι άδειο και ο χρήστης προσπαθήσει να εισέλθει σε κάποιο από τα endpoints, τότε θα του εμφανιστεί το αντίστοιχο μήνυμα:

![Screenshot_1](https://user-images.githubusercontent.com/103457872/177220499-0a44d954-f2ad-4b44-929d-d0bd08fcc3d3.png)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/insert_note', methods=['POST'])
Για την δημιουργία μίας νέας σημείωσης, ο χρήστης πρέπει να στείλει το κατάλληλο json από το body. Αν δεν έχει όλα τα στοιχεία τότε του εμφανίζεται το κατάλληλο μήνυμα, αλλιώς δημιουργείται με επιτυχία η νέα σημείωση. Όταν γίνει η δημιουργία της σημείωσης, σώζεται αυτόματα και η ημερομηνία που δημιουργήθηκε αυτή με την χρήση του datetime.now().

1)Επιτυχής δημιουργία
![Screenshot_2](https://user-images.githubusercontent.com/103457872/177220831-37788cda-6973-48b4-82b4-c47402c4ba19.png)


2)Ελλειπή στοιχεία(λείπει ο τίτλος)
![Screenshot_3](https://user-images.githubusercontent.com/103457872/177220832-cec214f6-1fe9-44d8-a91c-1c75056591f1.png)


@app.route('/get_note/<string:title>', methods=['GET'])
Για να αναζητήσει ο χρήστης μία σημείωση με βάση τον τίτλο θα πρέπει να προσθέσει στο link τον αντίστοιχο τίτλο. Ανάλογα με το αν υπάρχει στο collection του notes του εμφανίζεται το αντίστοιχο μήνυμα:

1)Σωστός τίτλος
![Screenshot_4](https://user-images.githubusercontent.com/103457872/177221214-a908fa4d-342e-4e56-9887-c2d71c1b4b4f.png)

2)Λάθος τίτλος
![Screenshot_5](https://user-images.githubusercontent.com/103457872/177221218-dc3fb9f7-4c7f-4d1a-ac3c-1f7cef98d7db.png)


-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/get_notes_by_keyword/<string:keywords>', methods=['GET'])
Για να μπορεί ο χρήστης να αναζητήσει τις σημειώσεις με το keyword που επιθυμεί, αρκεί να το περάσει στο route.Ανάλογα αν υπάρχει ή όχι έχει τα εξής αποτελέσματα:

1)Σωστό keyword
![Screenshot_7](https://user-images.githubusercontent.com/103457872/177602656-7d26137b-151f-4bdb-8268-d64071aa20ab.png)

2)Λάθος keyword
![Screenshot_8](https://user-images.githubusercontent.com/103457872/177602660-c059b232-533e-4d7a-b259-77fb005106ed.png)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/update_note/<string:title>', methods=['PUT'])
Για να γίνει το update χρησιμοποείται η μέθοδος PUT. Ο χρήστης πρέπει να δώσει τον τίτλο της σημείωσης που επιθυμεί να ανανεώσει. Αν δεν υπάρχει ενημερώνεται κατάλληλα. Αν υπάρχει τότε αποθηκεύεται στην μεταβλητή note και δημιουργείται η μεταβλητή new_note στην οποία με την χρήση του $set ορίζουμε τα δεδομένα που έστειλε ο χρήστης από το body του μηνύματος και τέλος κάνουμε update το note με το new_note.

Έστω ότι ο χρήστης θέλει να κάνει update το εξής record:
![Screenshot_1](https://user-images.githubusercontent.com/103457872/177603772-c61099f7-ac2f-4ef5-873c-debbcfae4c0a.png)

Έτσι το update γίνεται ώς εξής:
![Screenshot_2](https://user-images.githubusercontent.com/103457872/177604169-73587da9-afbd-46e8-aa18-a9d8e827db23.png)

Και το updated record φαίνεται παρακάτω(βλέπουμε ότι γίνεται update και στην μεταβλητή date_of_text ανάλογα με το πότε γίνεται το update):
![Screenshot_3](https://user-images.githubusercontent.com/103457872/177604172-de066937-dd00-4535-8689-4a0b91dfdd84.png)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/delete_note/<string:title>', methods=['DELETE'])

Αφού γίνει ο έλεγχος αν υπάρχει ο τίτλος της σημείωσης που περνάει ο χρήστης, ο κώδικας ψάχνει να βρει την εγγραφή που έχει τον συγκεκριμένο τίτλο και διαγράφεται με το delete_one.
Έστω ότι θέλουμε να διαγράψουμε την εξής σημείωση:
![Screenshot_1](https://user-images.githubusercontent.com/103457872/177604901-7503b42b-0557-4326-9679-61614cb93bc0.png)

Η διαγραφή γίνεται ώς εξής:
![Screenshot_2](https://user-images.githubusercontent.com/103457872/177605025-fee441a1-6286-4646-8c8c-430d6ad2a01b.png)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

Όσον αφορά την εμφάνιση των σημειώσεων σε χρονολογική σειρά υλοποιήθηκαν δύο endpoints, το get_notes_ascending και το get_notes_descending για αύξουσα και φθίνουσα χρονολογική εμφάνιση αντίστοιχα. Η διαφορά τους βρίσκεται στην αποθήκευση των δεδομένων στην μεταβλητή iterable, την οποία μετά εμφανίζω στον χρήστη. Για την αύξουσα σειρά χρησιμοποιείται η εντολή: iterable = notes.find().sort("date_of_text", 1) ενώ για την φθίνουσα χρησιμοποιείται η εντολή: iterable =  notes.find().sort("date_of_text", -1) όπου date_of_text είναι η αποθηκευμένη χρονολογία της κάθε σημείωσης.

@app.route('/get_notes_ascending', methods=['GET'])

![Screenshot_1](https://user-images.githubusercontent.com/103457872/177605723-1331a4fb-4acd-4089-ad89-fc592605e6ef.png)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/get_notes_descending', methods=['GET'])

![Screenshot_2](https://user-images.githubusercontent.com/103457872/177605727-780c1fa4-8ffa-4bb3-ade9-3d8db9be65cb.png)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/delete_student/<string:email>', methods=['DELETE'])

Για να μπορέσει ένας απλός χρήστης να διαγράψει τον λογαριασμό του, πρέπει το email που θα δώσει να είναι το ίδιο με αυτό που είναι αποθηκευμένο στο session['email'] (σε αυτό δηλαδή που έκανε το sign_in νωρίτερα). Αν είναι ο ίδιος τότε διαγράφεται ο λογαριασμός με την εντολή students.delete_one({"email": email}). Αν δεν είναι τότε ενημερώνεται με κατάλληλο μήνυμα ότι δεν έχει εξουσιοδώτηση να διαγράψει κάποιον άλλον λογαριασμό.

Έστω ότι θέλει ο παρακάτω χρήστης να διαγράψει τον λογαριασμό του αφού έχει κάνει επιτυχή σύνδεση:
![Screenshot_3](https://user-images.githubusercontent.com/103457872/177606523-9ee39539-0088-4e5f-a6ac-da4b2f75e949.png)

Αυτό γίνεται ώς εξής:
![Screenshot_4](https://user-images.githubusercontent.com/103457872/177606871-3d45c3f6-a229-4fc1-9bd0-e0ba01dd2581.png)


-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/add_new_admin', methods=['POST'])


-------------------------------------------------------------------------------------------------------------------------------------------------------------------- 

@app.route('/admin_delete_student/<string:email>', methods=['DELETE'])

Η διαφορά του admin σε σχέση με τους υπόλοιπους χρήστες είναι ότι ο ρόλος του είναι admin(role=admin) αντί για role=user. Αυτός μπορεί να διαγράψει οποιονδήποτε χρήστη. Αρχικά γίνεται ένας έλεγχος στο endpoint αν το email αντιστοιχεί με το email του admin. Αν ο έλεγχος είναι επιτυχής, τότε αν δώσει ένα σωστό email μπορεί να διαγράψει αυτόν τον λογαριασμό χωρίς να γίνεται ο έλεγχος που γίνεται στους απλούς χρήστες. Αν ο έλεγχος είναι ανεπιτυχής, ενημερώνεται ότι δεν έχει πρόσβαση στο συγκεκριμένο endpoint.

